from enaml.widgets.api import (
    Window, Container, Form, Label, Field, GroupBox, ObjectCombo, CheckBox, 
    WebView, PushButton, Dialog, Notebook, Page, MultilineField
)
from enaml.stdlib.fields import IntField
from enaml.layout.api import vbox, hbox, spacer, grid, align
from traits_enaml.widgets.data_frame_table import DataFrameTable

import logging

def convert(value):
    if isinstance(value, str):
        try:
            return unicode(value, encoding='utf-8')
        except UnicodeDecodeError:
            return unicode(value, encoding='latin-1')
    else:
        return unicode(value)

enamldef CSVImportView(Window): windw:
    attr options
    title = "Import Delimited File as DataFrame"
    Container:
        constraints = [
            vbox(
                opts,
                col_opts,
                nbook,
                hbox(
                    spacer,
                    cancelButton,
                    loadButton
                )
            ),
            nbook.height >= 300, 
            opts.height <= 150,
            col_opts.height <= 200,
        ]
        GroupBox: opts:
            title = 'Global Options'
            Container:
                constraints = [
                    hbox(
                        vbox(
                            delims_lbl,
                            delims,
                            delim_other,
                            spacer
                        ), 
                        spacer(200).flex(),
                        vbox(
                            header_row_lbl,
                            header_row,
                            has_header_row_cb,
                            spacer
                        ), 
                        spacer(200).flex(),
                        vbox(
                            index_cols_lbl,
                            index_cols,
                            multi_index_cols,
                            dates,
                            spacer
                        )
                    ),

                    delims_lbl.width == delims.width,
                    header_row_lbl.width == header_row.width,
                    has_header_row_cb.width == header_row.width,
                    index_cols_lbl.width == index_cols.width,
                ]
                Label: delims_lbl:
                    text = 'Delimiter'
                ObjectCombo: delims:
                    items = options.delims_keys
                    selected = 'comma'
                    selected ::
                        if selected == 'custom':
                            options.delim = delim_other.text
                        else:
                            options.delim = options.delims_dict[selected]
                Field: delim_other:
                    visible << delims.selected == 'custom'
                    text >> options.delim
                    submit_triggers = ['auto_sync', 'lost_focus', 'return_pressed']
                Label: header_row_lbl:
                    text = "Header Row"
                IntField: header_row:
                    enabled << has_header_row_cb.checked
                    value >> (options.header_row)
                    submit_triggers = ['auto_sync', 'lost_focus', 'return_pressed']
                    minimum = 0
                    maximum << options.df.shape[0]
                CheckBox: has_header_row_cb:
                    text = "Has Header Row"
                    checked = True
                    toggled ::
                        if not has_header_row_cb.checked:
                            options.header_row = None
                        else:
                            options.header_row = header_row.value
                Label: index_cols_lbl:
                    text = "Index Column(s)"
                ObjectCombo: index_cols:
                    items = ["None"] + map(str, range(options.df.shape[1])) + ["Multi-Index"]
                    selected := options.index_column
                Field: multi_index_cols:
                    visible << index_cols.selected == 'Multi-Index'
                    placeholder = "Comma Separated" 
                    text := options.index_sequence          
                    submit_triggers = ['auto_sync', 'lost_focus', 'return_pressed'] 
                CheckBox: dates:
                    text = "Parse Index Columns as Dates"
                    checked := options.parse_dates
        GroupBox: col_opts:
            title = 'Column Options'
            constraints = [
                vbox(
                    col_lbl,
                    cols,
                    dtype_lbl,

                    hbox(
                        transfers, spacer, open_btn, reload_btn
                    ),
                    error
                )
            ]
            Label: col_lbl:
                text = "Column"
            ObjectCombo: cols:
                items << list(options.df.columns.values)
                selected = list(options.df.columns.values)[0]
                selected ::
                    options.selected_column = selected
                to_string = convert
            #CheckBox:
            #   text = 'Ignore This Column'
            #   checked = False
            Label: dtype_lbl:
                text = 'Data Type'
            PushButton: open_btn:
                text = 'Edit Transfer Functions'
                clicked ::
                    options.open_transfers_file()
                    windw.send_to_back()
            PushButton: reload_btn:
                text = 'Reload Transfer Functions'
                clicked ::
                    options.reload_transfers()
                    transfers.items = options.transfer_handler.get_list_options_for_column(cols.selected)
            Field: error:
                text := str(options.last_error)
                read_only = True
                visible << options.last_error is not None
            ObjectCombo: transfers:
                # items = options.default_dtypes.values() + options.transfer_functions.keys()
                #selected << str(options.selected_transfer_functions[cols.selected]) if cols.selected in options.selected_transfer_functions else options.default_dtypes[type(options.df[cols.selected][0])]

                items << options.transfer_handler.get_list_options_for_column(cols.selected)
                selected << options.transfer_handler.transfer_for_col(cols.selected)
                selected ::
                    logging.info("SELECTED DROPDOWN: " + selected)
                    # options.selected_transfer_functions[cols.selected] = selected
                    options.selected_column = cols.selected
                    options.transfer_handler.set_col_transfer(cols.selected, selected)
                    options._update_dataframe()
                #selected ::
                #   options.selected_transfer_functions[cols.selected] = selected #if selected is not options.default_dtypes[type(options.df[cols.selected][0])] else None
                #   options._selected_transfer_functions_changed()

        Notebook: nbook:
            tab_style = 'preferences'
            tabs_movable = False
            Page:
                title = 'Table Preview'
                closable = False
                tool_tip = 'Table Preview'
                Container:
                    #WebView: table:
                    #   html << options.html
                    DataFrameTable: table:
                        data_frame << options.df_trans
                        visible << not options.parse_error
                    Label: parse_error:
                        text = "The data could not be parsed with the selected options."
                        visible << options.parse_error
            Page:
                title = 'Plain Text'
                closable = False
                tool_tip = 'Plain Text'             
                Container:
                    MultilineField: plain_text:
                        read_only = True
                        text := options.plain_text

        PushButton: cancelButton:
            text = "Cancel"
            clicked :: 
                windw.close()
        PushButton: loadButton:
            text = "Import DataFrame"
            default = True
            clicked :: 
                windw.close()
                options.ok_pressed()

